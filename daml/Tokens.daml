daml 1.2 module Tokens where
import Structs


template TokenIssue
  with
    issuer: Party
    operator: Party
    investors: [Party]
    outstanding: Int
    balances: [(Party, Int)]
    listing: RealEstateListing
    locked: Bool
  where
    signatory issuer, operator
    observer investors

    -- ERC20 Interfaces
    nonconsuming choice TokenIssue_TotalSupply: (
        Int
      )
      with
        requestor: Party
      controller requestor
      do
        return (truncate (listing.fiatValueTotal / listing.chunkFiatSizes))
    
    nonconsuming choice TokenIssue_BalanceOf: (
        Int
      )
      with
        requestor: Party
        investor: Party
      controller requestor
      do
        case (find (\(add, bal) -> add == investor) balances) of
          Some (add, bal) -> return bal
          None -> return 0

--     allowance(address tokenOwner, address spender) public view returns (uint remaining);
--     transfer(address to, uint tokens) public returns (bool success);
--     approve(address spender, uint tokens) public returns (bool success);
--     transferFrom(address from, address to, uint tokens) public returns (bool success);

    -- Servicing choices
    controller issuer can
      TokenIssue_AllocateTokens: (
          ContractId TokenIssue
        )
        with
          investor: Party
          quantity: Int
        do
          assert (quantity <= outstanding)
          create this with 
            balances = (investor, quantity) :: balances
            outstanding = (outstanding - quantity)
      
      TokenIssue_AddInvestors: (
          ContractId TokenIssue
        )
        with
          newInvestors: [Party]
        do
          create this with
            investors = newInvestors ++ investors, locked = False
    
    controller operator can
      TokenIssue_LockToken: (
          ContractId TokenIssue
        )
        do
          create this with
            locked = True


      -- TransferTokens
      -- Close out position


template TokenUpdateNotice
  with
    issuer: Party
    operator: Party
    token: ContractId TokenIssue
    newUsers: [Party]
  where
    signatory operator

    controller issuer can
      TokenUpdateNotice_Unlock: (
          ContractId TokenIssue
        )
        do
          exercise token TokenIssue_AddInvestors with
            newInvestors = newUsers
    
    controller operator can
      TokenUpdateNotice_AddInvestor: (
          ContractId TokenUpdateNotice
        )
        with
          newUser: Party
        do
          create this with
            newUsers = newUser :: newUsers


template TokenBuyinBid
  with
    investor: Party
    issuer: Party
    tokenOffer: ContractId TokenIssue
    quantity: Int
  where
    signatory investor

    controller issuer can
      TokenBuyinBid_AcceptTokenBid: (
          ContractId TokenIssue,
          ContractId TokenContract
        )
        do
          to_ <- fetch tokenOffer
          issue <- exercise tokenOffer TokenIssue_AllocateTokens with ..
          shares <- create TokenContract with symbol = to_.listing.issueSymbol, ..
          return (issue, shares)


template TokenContract
  with
    issuer: Party
    investor: Party
    symbol: Text
    quantity: Int
  where
    signatory issuer, investor
